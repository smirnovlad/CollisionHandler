# Solution

В начале решения задачи рассматривал несколько возможных путей:
<ul>
  <li>Разделить окно на квадратные клетки некоторого размера и в процессе перемещения кругов поддерживать, какие кругы частично или полностью покрывают каждую клетку. В данном варианте решения задачи есть множество нюансов. </li>
  <li>Хранить для каждого круга "хитбокс", т.е. прямоугольник, полностью содержащий данный круг. В процессе перемещения кругов проверять хитбоксы на пересечения/касания при помощи сканирующей прямой (ScanLine) и дерева интервалов. Также возникает ряд вопросов к такому подходу. </li>
  <li>В процессе решения задачи делить окно на квадраты в соответствии с определением структуры данных QuadTree, на чём я и остановился. </li>
</ul>

# Complexity

Ожидаемая асимптотика времени добавления круга в структуру: **O(log n)**.

В худшем случае добавление круга занимает **O(n)** операций.

Асимптотика времени работы одной итерации при условии равномерного распределения кругов есть **O(n^1.5 log n)**,
поскольку ожидаемое время спуска по дереву QuadTree есть **O(log n)** и ожидаемое число соседей оценивается **O(sqrt(n))** .

В силу ограниченности числа соседей, ожидаемая асимптотика времени работы одной итерации: **O(n log n)**.

# Implementation details

Для поддержки структуры QuadTree разработано две реализации: дерево на куче и дерево на стеке.
Преимущество второго варианта относительно первого заключается в скорости работы.
В процессе перемещения кругов при работе с ноутбуком случаются зависания (фризы), поэтому у меня и появилась идея поддержать QuadTree на стеке.
Невооружённым взглядом кажется, что при использовании дерева на стеке фризов действительно становится меньше.
Замечу, что на втором, куда более мощном, компьютере фризов не видно.

Если использовать выведенные формулы для накладывающихся друг на друга кругов без изменения их относительного положения,
возможно неопределённое поведение в их дальнейшем движении.
Поэтому перед изменением скоростей двух касающихся кругов (которые могут накладываться в силу дискретности времени и
ограничений на скорость кругов) я двигаю один из них вдоль линии их центров так, чтобы они касались друг друга.
В таком случае на следующей итерации шары не могут накладываться друг друга. Более умного решения не придумал...

При выходе кругов за пределы окна я предполагаю, что смещение круга за край не велико и поэтому сдвигаю шар до положения
касания с соответствующей границей.

Комментарии относительно изменений изначального исходного кода есть в самом коде.

# Architecture

Скоро здесь появится UML-диаграмма классов.

# Build

В проекте есть 3 таргета для запуска:
<ul>
  <li> main </li>
  <li> test </li>
  <li> test_two_balls </li>
</ul>
Последние два я использовал для тестирования решения.

Для запуска приложения необходимо выбрать таргет **main**.

# References

[Формулы для расчёта движения кругов](https://en.wikipedia.org/wiki/Elastic_collision)

[QuadTree #1](https://vixra.org/pdf/2005.0108v1.pdf)

[QuadTree #2](https://github.com/pvigier/Quadtree)
